
---
# ðŸ“˜ Notes on **CRD (Custom Resource Definition)**

---

## ðŸ”¹ 1. What is a CRD?

- In Kubernetes, you already know built-in objects like **Pod, Deployment, Service, ConfigMap**.
    
- But sometimes, these built-ins are not enough for your use case.
    
- **Custom Resource Definition (CRD)** allows you to **create your own object type** in Kubernetes.
    

ðŸ‘‰ In short:  
**CRD = a way to teach Kubernetes new "vocabulary".**

---

## ðŸ”¹ 2. Real-World Analogy

- Think of Kubernetes like a **dictionary**.
    
- By default, it knows words like "Pod", "Service".
    
- But what if you want to add your own word, like "Database" or "BackupJob"?
    
- A **CRD** is like adding a new word to the dictionary, so Kubernetes can understand and manage it.
    

Example:

- You create a CRD called **MySQLDatabase**.
    
- Then you can create a resource like:
    

```yaml
apiVersion: database.mycompany.com/v1
kind: MySQLDatabase
metadata:
  name: customer-db
spec:
  version: "8.0"
  storage: "20Gi"
```

Now Kubernetes knows what a `MySQLDatabase` is, because you defined it.

---

## ðŸ”¹ 3. Why do we need CRDs?

1. **Extend Kubernetes functionality** without changing its core code.
    
2. Let teams define **custom APIs** for their apps.
    
3. Used heavily in **Operators** (automation for databases, queues, monitoring tools, etc.).
    

---

## ðŸ”¹ 4. How CRD works

1. **Step 1: Define CRD**
    
    - You write a `CustomResourceDefinition` YAML that defines:
        
        - The name of the resource (kind).
            
        - The API group.
            
        - The versions.
            
        - The schema (validation rules).
            
    
    Example:
    
    ```yaml
    apiVersion: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    metadata:
      name: mysqls.database.mycompany.com
    spec:
      group: database.mycompany.com
      versions:
        - name: v1
          served: true
          storage: true
          schema:
            openAPIV3Schema:
              type: object
              properties:
                spec:
                  type: object
                  properties:
                    version:
                      type: string
                    storage:
                      type: string
      scope: Namespaced
      names:
        plural: mysqls
        singular: mysql
        kind: MySQL
        shortNames:
        - mydb
    ```
    
2. **Step 2: Use your CRD**
    
    - After applying above CRD, you can create objects of type `MySQL`.
        
    
    ```yaml
    apiVersion: database.mycompany.com/v1
    kind: MySQL
    metadata:
      name: my-first-db
    spec:
      version: "8.0"
      storage: "10Gi"
    ```
    
3. **Step 3: Controller / Operator (optional but powerful)**
    
    - A controller watches these custom resources and takes actions.
        
    - Example: A MySQL Operator sees a `MySQL` object and automatically deploys StatefulSets + PVCs.
        

---

## ðŸ”¹ 5. Where CRDs are used in industry?

- **Prometheus Operator** â†’ CRDs like `Prometheus`, `Alertmanager`, `ServiceMonitor`.
    
- **Cert-Manager** â†’ CRDs like `Certificate`, `ClusterIssuer`.
    
- **Kafka Operator** â†’ CRDs like `KafkaCluster`.
    
- **ArgoCD** â†’ CRDs like `Application`.
    

ðŸ‘‰ Basically, almost every modern Kubernetes tool you install uses CRDs behind the scenes.

---

## ðŸ”¹ 6. Key Points to Remember

- CRD = new **type of Kubernetes resource**.
    
- You define CRD once â†’ then you can create multiple custom resources.
    
- CRD is only a definition; actual behavior comes when you add a **controller** (logic).
    
- Without a controller, CRD objects just sit in etcd (no real action).
    
---

## âœ… Example: Create a Custom Resource Definition for "Database"

### Step 1: Define the CRD

```yaml
# database-crd.yaml
apiVersion: apiextensions.k8s.io/v1   # API group for CRDs
kind: CustomResourceDefinition        # We are creating a CRD
metadata:
  name: databases.mycompany.com       # CRD name: <plural>.<group>
spec:
  group: mycompany.com                # Custom API group
  versions:
    - name: v1
      served: true                    # API is available
      storage: true                   # This version is used to store in etcd
      schema:                         # Validation schema for CR
        openAPIV3Schema:
          type: object
          properties:
            spec:                     # Define fields under "spec"
              type: object
              properties:
                engine:
                  type: string        # e.g., mysql, postgres
                version:
                  type: string        # e.g., 8.0, 13
                storage:
                  type: string        # e.g., 20Gi
  scope: Namespaced                   # CR applies inside a namespace
  names:
    plural: databases                 # plural used in CLI: `kubectl get databases`
    singular: database                # singular: `kubectl get database`
    kind: Database                    # Custom Kind: Database
    shortNames:
      - db                            # Shortcut: `kubectl get db`
```

ðŸ”Ž **Explanation inside code**:

- `group: mycompany.com` â†’ groups your custom resource under API `mycompany.com`.
    
- `versions: v1` â†’ you can have multiple versions (`v1`, `v2beta1`, etc).
    
- `scope: Namespaced` â†’ each namespace can have its own `Database` object.
    
- `names` â†’ how you will interact with it (`kubectl get databases`).
    

---

### Step 2: Apply the CRD

```bash
kubectl apply -f database-crd.yaml
```

âœ… This creates a new API resource in Kubernetes:

```bash
kubectl get crd
NAME                        CREATED AT
databases.mycompany.com     2025-08-31T12:00:00Z
```

---

### Step 3: Create a Custom Resource (CR) using CRD

```yaml
# my-database.yaml
apiVersion: mycompany.com/v1   # Must match CRD group and version
kind: Database                 # Must match CRD kind
metadata:
  name: mydb
  namespace: default
spec:
  engine: mysql                # Custom field defined in CRD
  version: "8.0"
  storage: "20Gi"
```

Apply:

```bash
kubectl apply -f my-database.yaml
```

Check:

```bash
kubectl get databases
NAME    AGE
mydb    10s
```

---

### Step 4: See the Custom Object

```bash
kubectl get db mydb -o yaml
```

Youâ€™ll see:

```yaml
apiVersion: mycompany.com/v1
kind: Database
metadata:
  name: mydb
spec:
  engine: mysql
  version: "8.0"
  storage: "20Gi"
```

---

âš¡ **Key Point**:  
CRD **just defines the object**, but does **not implement logic**.  
ðŸ‘‰ To make it actually **create a real database** (like a Pod running MySQL), you need a **Controller** or **Operator**.

Example:

- CRD = like defining a new "table schema".
    
- CR (Custom Resource) = like inserting a row in that table.
    
- Controller/Operator = the "program" that reads that row and takes action.
    

---
