
---

## What is Kafka ? 

Kafka is a tool used for managing and moving data between different parts of a system, especially <font color="#ffff00">when those parts need to communicate quickly and handle a lot of information.</font>

Open-source distributed (multiple server) event (data) streaming platform.

### **Problem Kafka Solves:**

Imagine a social media app where users can like posts, and the app needs to notify the post's owner when someone likes their post. The traditional approach would involve directly updating the database and sending a notification every time a like happens. But this can become a problem when there are millions of users and likes happening at the same time. It could overwhelm the database, slow down the app, and cause notifications to be delayed.

 <font color="#ffff00">Executing an API</font> call is typically a <font color="#ffff00">synchronous task,</font> meaning that the caller has to wait for the API to finish its work and send back a response before it can continue. This waiting can take time, especially if the API is doing something complex.

Kafka, on the other hand, provides <font color="#ffff00">asynchronous operations.</font> This means that when a system sends a message to Kafka, it doesn't have to wait for a response. Kafka takes care of delivering the message to the right place, allowing the system to continue working without delay. This makes Kafka very useful for scenarios where you don't want to wait around for something to finish, like processing large amounts of data or handling real-time events.

### **How Kafka Helps:**

Kafka acts like a middleman (or a "broker") that handles all these messages (like "User A liked Post B") efficiently. Hereâ€™s how it works in simple terms:

1. **Producers**: These are the parts of your app that create messages. For example, when a user likes a post, the app creates a message saying, "User A liked Post B" and sends it to Kafka.

2. **Kafka Topics**: Kafka stores these messages in something called "topics." Think of a topic as a specific category or channel where all similar messages are grouped together. In this case, you might have a topic called "post-likes."

3. **Consumers**: These are parts of your app that read and process these messages. For example, a notification service can consume messages from the "post-likes" topic to send a notification to the post's owner.

### **Real-World Example: Social Media Likes and Notifications**

- **When a user likes a post**: 
   - The app (Producer) sends a message to the "post-likes" topic in Kafka.
- **Kafka stores this message**:
   - The message sits in the "post-likes" topic, ready for any service that needs it.
- **Notification service (Consumer)**:
   - This service reads the message from the "post-likes" topic and sends a notification to the post's owner.

### **Benefits:**
- **Scalability**: Kafka can handle a massive number of messages, so even if millions of users are liking posts at the same time, it wonâ€™t slow down.
- **Decoupling**: The services that produce and consume messages are independent. The app creating likes doesnâ€™t need to know how the notification is sent.
- **Reliability**: Messages are stored in Kafka until they are processed, ensuring that no notifications are missed.


---

 Basic Kafka terminologies :

1. **Producer**:  
   A producer is like a messenger that sends messages (or data) to Kafka. For example, if you have a service that generates data (like user activity on a website), it acts as a producer by sending that data to Kafka.

2. **Consumer**:  
   A consumer is the receiver that takes messages from Kafka. For example, if you have another service that processes or stores the data generated by users, it acts as a consumer by reading those messages from Kafka.

3. **Topic**:  
   A topic is like a channel or category where messages are sent. Producers send messages to a specific topic, and consumers read messages from that topic. For example, you could have a "user-activity" topic for all messages related to user actions.

4. **Partition**:  
   A topic can be split into smaller parts called partitions. This helps Kafka handle large amounts of data efficiently. Each partition can be thought of as a separate sequence of messages within a topic, allowing Kafka to distribute the workload across multiple servers.

5. **Broker**:  
   A broker is a server in a Kafka cluster (a group of connected Kafka servers). The broker's job is to manage topics, store messages, and handle communication between producers and consumers.

6. **Cluster**:  
   A cluster is a group of Kafka brokers working together. If one broker fails, the cluster can still function, making Kafka reliable and scalable.

7. **ZooKeeper**:  
   ZooKeeper is a tool that helps manage the Kafka cluster. It keeps track of the brokers, topics, and partitions, ensuring everything runs smoothly. However, newer versions of Kafka are moving away from using ZooKeeper.

8. **Offset**:  
   An offset is a unique number that identifies each message within a partition. Consumers use offsets to keep track of which messages they've read, so they don't process the same message twice.

9. **Consumer Group**:  
   A consumer group is a group of consumers that work together to read messages from a topic. Each consumer in the group reads from different partitions of the topic, allowing them to share the workload.


----

Here are the commands exactly as you provided:

### ðŸŸ¢ INSTALLATION COMMANDS

```bash
zookeeper-server-start.bat ..\..\config\zookeeper.properties
```

```bash
kafka-server-start.bat ..\..\config\server.properties
```

```bash
kafka-topics.bat --create --topic my-topic --bootstrap-server localhost:9092 --replication-factor 1 --partitions 3
```

```bash
kafka-console-producer.bat --broker-list localhost:9092 --topic my-topic
```

```bash
kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic my-topic --from-beginning
```

### ðŸŸ¢ SENDING MESSAGES COMMANDS

```bash
zookeeper-server-start.bat ..\..\config\zookeeper.properties
```

```bash
kafka-server-start.bat ..\..\config\server.properties
```

```bash
kafka-topics.bat --create --topic foods --bootstrap-server localhost:9092 --replication-factor 1 --partitions 4
```

```bash
kafka-console-producer.bat --broker-list localhost:9092 --topic foods --property "key.separator=-" --property "parse.key=true"
```

```bash
kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic foods --from-beginning --property "key.separator=-" --property "print.key=false"
```


----


### **Topic**
- **Definition**: A topic is a named container that holds similar types of events or messages. Its unique identifier is its name.
- **Example**: A "Student" topic might contain all student-related data, while an "Order" topic could hold order-related data.
- **Analogy**: Think of a topic like a table in a database, where each table stores related information.
- **Location**: Topics reside within a Kafka broker (server).
- **Message Flow**:
  - **Producer**: The producer sends messages to a topic, which are then stored in partitions (either in a round-robin manner across partitions or directly into specific partitions).
  - **Consumer**: The consumer continuously polls the topic for new messages using the topic name.

### **Partition**
- **Definition**: A topic is divided into multiple parts called partitions. This allows Kafka to distribute data across multiple brokers, making the system scalable and fault-tolerant.
- **Replication Factor**: Each partition can be copied (replicated) to other brokers based on a replication factor. This ensures fault toleranceâ€”if one broker fails, the data is still available on another.
- **Partition Structure**:
  - **Location of Messages**: The actual messages are stored within partitions.
  - **Number of Partitions**: When creating a topic, you specify the number of partitions. This number can be adjusted later.
  - **Order within Partitions**: Each partition is an ordered, immutable sequence of records. This means that messages within a partition are stored in the exact order they were produced.
  - **Offset**: Each message in a partition has a unique identifier called an offset, which is an incremental number. This offset helps in tracking the order of messages.
  - **Growth**: As new records are produced, the partition grows, and the offset increases.

---

We can send  data through Producer to consumer as key-value pair or only value .

### 1. **With Key:**
- **Partitioning**: When you send a message with a key, Kafka uses the key to determine which partition the message will go to. The key is hashed, and this hash value determines the partition.
- **Order within Partition**: Kafka preserves the order of messages **within** a partition. This means that if you send multiple messages with the same key, they will all go to the same partition and be consumed in the order they were produced.
- **Order across Partitions**: However, if messages with different keys are sent to different partitions, the order between partitions is not guaranteed. The consumer will read from multiple partitions, and the overall order of messages may seem mixed.

### 2. **Without Key:**
- **Round-robin Partitioning**: If you send a message without a key, Kafka typically distributes messages across partitions in a round-robin fashion. This means that consecutive messages may end up in different partitions.
- **Order within Partition**: As with keyed messages, order is still preserved within each partition.
- **Order across Partitions**: Since messages are spread across partitions, the order between partitions is not guaranteed.

### Key Points:
- **Order Guarantee**: Kafka guarantees message order **within a single partition**. If you need to preserve the order of all messages, you should either:
  - Use a single partition (which limits scalability), or
  - Ensure that all related messages (which need to be in order) use the same key so that they all go to the same partition.

- **No Global Order**: When you have multiple partitions, Kafka does not guarantee a global order across all partitions, regardless of whether you use a key or not.
 